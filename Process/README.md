# 프로세스와 스레드

## 1. 프로세스의 개념과 상태변화

- 프로세스의 정의
    - IBM 운영체제에서의 작업(task)
    - 실행 중인 프로그램(가장 일반적인 정의)
    - 비동기적 행위
    - 실행 중인 프로시저
    - 실행 중인 프로시저의 제어 추적
    - 운영체제에 들어 있는 프로세스 제어 블록 (PCB)
    - 프로세서에 할당하여 실행 할 수 있는 개체 디스패치가 가능한 대상
        - 디스패치란????
            찾아보았더니, 디스패치는 어떤 메소드를 호출 할 것인가를 결정하여 그것을 실행하는 과정이라고 함. 동적 디스패치와 정적 디스패치가 존재하고, 동적 디스패치는 메서드 오버라이딩이 되어있는 경우 실행 시점에 어떤 메서드를 실행 할지 결정 되는 것. 정적 디스패치는 그와 다르게 컴파일 시점에 어떤 메서드를 실행 할 지 결정 되는 것.
    * 디스크에 있는 프로그램(컴파일 한 코드와, 전역변수, 문자열, 문자열 상수등)이 메모리에 적제되면 이를 프로세스가 되었다고 한다.
    * 프로세스의 일반적인 메모리 구조는
        - 스택(데이터를 일시 저장하는 영역)
        - 힙 영역(동적 할당, 해제를 하는 부분)
        - 데이터 영역(프로그램의 가상 주소 공간)
        - 코드 영역(실행 명령을 포함하는 메모리이거나 목적파일에 있는 프로그램 영역)

```C

char notInit[10000];
char init[] = "I love computer";

int main(int argc, char *argvp[])
{
    float f;
    int i;
    char *cp = malloc(10000);
}

```     

이런 코드가 있다고 치면, 맨 위 전역 변수는 데이터 부분에 들어가고  
main 문 안의 지역 변수 및 인자는 스택 영역에 들어간다.

동적 할당을 한 부분은 힙 메모리에 들어간다 !!

## 1. 프로세스의 개념

* 프로세스의 종류

- 역할
    * 시스템(커널 프로세스)
        - 모든 시스템 메모리와 프로세스의 명령에 액세스 할 수 있는 프로세스
        - 프로세스 실행 순서를 제어하거나 다른 사용자 및 커널 영역을 침범하지 못하게 감시
        - 사용자 프로세스를 생성하는 기능
    * 사용자 프로세스
        - 사용자 코드를 수행하는 프로세스이다.
- 병행 수행 방법
    * 독립 프로세스
        - 다른 프로세스에 영향을 주지 않거나
        -  다른 프로세스의 영향을 받지 않으면서 수행하는 병행 프로세스
    * 협력 프로세스
        - 다른 프로세스에 영향을 주거나, 다른 프로세스에서 영향을 받는 병행 프로세스

## 2. 프로세스의 상태 변화와 상태 정보
    - 프로세스의 상태 변화

1. 생성
비실행 상태로 시작
2. 디스패치
3. 실행 -> 종료
3. 실행 -> 인터럽트
4. 인터럽트 -> 비실행


* 프로세스의 상태 변화는 운영체제가 프로세서 스케줄러 이용하여 관리

* 작업 스케줄러는 스풀러가 디스크에 저장한 작업 중 실행할 작업 선정하고 준비 리스트에 삽입하여 다중 프로그래밍의 정도 결정

* 프로세스 스케줄러는 선정한 작업의 상태를 변화시키며 프로세스의 생성에서 종료까지 과정 수행

*프로세스의 상태 변화 테이블*

|프로세스의 상태변화|표기방법|
|:----|:----
|1. 준비 -> 실행 | dispatch(프로세스 이름)|
|2. 실행 -> 준비 | timeout(프로세스 이름)|
|3. 실행 -> 대기(보류)| block(프로세스 이름)|
|4. 대기(보류) -> 준비| wakeupI(프로세스 이름)|


* 프로세스 제어 블록 (PCB)
    - 운영체제가 프로세스 제어 시 필요한 프로세스 상태 정보 저장
    - 특정 프로세스 정보 저장하는 데이터 블록이나 레코드(작업 제어 블록)
    - 프로세스가 생성되면 메모리에 프로세스 제어 블록 생성
    - 프로세스가 실행 종료하면 해당 프로세스 제어 블록도 삭제

*프로세스 제어 블록 예시*

|제어블록|내용|
|:-----|:------------------
|프로세스 식별자|각 프로세스의 고유 식별자|
|프로세스 상태|생성, 준비, 실행, 대기, 중단 등 상태 표시|
|프로그램 카운터|프로세스를 실행하는 다음 명령의 주소 표사|
|레지스터 저장 영역|누산기,인덱스 레지스터, 스택포인터, 범용레지스터 등 조건 코드 정보로, 컴퓨터 구조에 따라 수나 형태가 다름, 인터럽트가 발생하면 프로그램 카운터와함께 저장되어 재실행 할 때 원래대로 복귀할 수 있게 한다.
|프로세스 스케줄링 정보|프로세스의 우선순위, 스케줄링 큐의 포인터, 기타 스케줄 매개변수|
|계정 정보| 프로세스 사용시간, 실제 사용시간, 사용 상한시간, 계정번호, 프로세스 번호 등등|
|입출력상태,메모리관리정보 등등|특별한 입출력 요구 프로세스에 할당된 입출력장치, 파일리스트, 메모리 시스템에 따른 상,하한 레지스터 등등|

* 프로세스의 문맥 교환(Context Switching)
    - 실행 중인 프로세스의 제어를 다른 프로세스에 넘겨 실행 상태가 되도록 하는것
    - 프로세스 문맥 교환이 일어나면 프로세서의 레지스터에 있던 내용 저장



## 프로세스의 관리

- 프로세스의 구조
    - 프로세스 실행 중 프로세스 생성 시스템 호출 이용, 새로운 프로세스 생성
    - 프로세스 생성 순서를 저장, 부모 - 자식 관계 유지하여 계층적 생성
    - 생성하는 프로세스는 부모 프로세스, 생성되는 프로세스는 자식 프로세스 라고 한다.
    - 부모 프로세스는 자식 프로세스를 생성 과정 반복하면서 계층 구조 형성

## 프로세스의 생성

- 프로세스의 생성 시기
    - 일괄처리 환경: 작업이 도착할 때 프로세스 생성
    - 대화형 환경: 새로운 사용자가 로그온 할 때 프로세스 생성

- 프로세스 생성 시 필요한 세부 작업 순서
    1. 새로운 프로세스에 프로세스 식별자 할당
    2. 프로세스의 모든 구성 요소를 포함 할 수 있는 주소 공간과 프로세스 제어 블록 공간 할당
    3. 프로세스 제어 블록 초기화
    4. 링크 (해당 큐에 삽입)

- 프로세스가 새로운 프로세스 생성 시 다음 두가지 실행 발생
    - 부모 프로세스와 자식 프로세스 동시 실행
    - 부모 프로세스는 자식 프로세스 모두 종료 할 때까지 대기



* 내가 해봤던 경험

- Linux Systemctl Service 등록 할 때 몇가지 해야 할 것들이 있었는데.

```text

[Unit]
Description=PLC Data Sender

[Service]
Type=oneshot
User=donghee
ExecStart=/bin/sleep 15
ExecStart=/bin/usr/npm start
TimeoutStartSec=0
RemainAfterExit=yes

WorkingDirectory=/home/donghee/poc-master/donghee-testbench/templates

[Install]
WantedBy=default.target
```
이런식으로 systemctl 서비스 등록을 해본 적이 있었다.

이 때 Type 에 보면 simple, forking, oneshot, notify, dbus 등이 있었는데

simple 의 경우 유닛이 시작된 경우 즉시 완료되었다고 판단했고  

forking의 경우 자식 프로세스 생성이 완료되는 단계까지 systemd 시작이 완료되었다고 판단하게 되었다.   

이 때 부모 프로세스를 추적 할 수 있도록 PIDFile= PID 파일 을 선언 해줬어야 한다 !!

또한 자식 프로세스 생성이 완료되면 부모프로세스는 종료되어서 -> 일종의 서비스 데몬으로 자식 프로세스들이 동작 할 때 적합했다!

이 때 PID 파일을 모르거나 못만들었다고 하면..

```text
[Unit]
Description=PLC Data Sender

[Service]
Type=forking
User=donghee
ExecStart=/bin/sleep 15
ExecStart=/bin/usr/npm start
TimeoutStartSec=0
RemainAfterExit=yes
GuessMainPID=yes

WorkingDirectory=/home/donghee/poc-master/donghee-testbench/templates

[Install]
WantedBy=default.target
```

이런식으로 GuessMainPID=yes 로 PID 추측 기능을 인에이블 하자.



## 3. 프로세스의 종료
- 프로세스의 종료
    - 프로세스가 마지막 명령 실행, 종료하여 운영체제에 프로세스의 삭제 요청
    - 일괄 처리 환경 : 작업 종료의 의미 신호로 인터럽트 발생 또는 시스템 호출로 중단 명령
    - 대화형 환경 : 사용자가 로그오프하거나 터미널 닫음
    - abort 명령어로 프로세스 종료
    - 부모 프로세스의 자식 프로세스 종료
        - 보통 부모 프로세스 종료하면 운영체제가 자식 프로세스도 종료
        - 자식 프로세스가 할당된 자원을 초과하여 자원을 사용 할 때
        - 자식 프로세스에 할당한 작업이 더는 없을 때
    - exit 명령어: 유닉스에서 프로세스 종료
    - wait 명령어: 부모 프로세스가 자식 프로세스의 종료 기다림
    - 프로세스 종료 이유
        - 정상 종료 : 프로세스가 운영체제의 서비스 호출
        - 시간 초과
        - 실패 : 파일 검색 실패, 입출력 횟수가 명시된 횟수를 초과하여 실패 할 때
        - 산술, 보호, 데이터 오류, 메모리부족, 액세스 위반 등등

## 4. 프로세스의 제거

- 프로세스 제거
    - 프로세스 파괴
    - 사용하던 자원 시스템에 돌려주고, 해당 프로세스는 시스템 리스트나 테이블에서 사라짐
    - PCB 회수
    - 프로그램은 여전히 디스크에 저장
    - 자식 프로세스는 부모 프로세스를 제거하면 자동 제거

## 5. 프로세스의 중단과 재시작
- 프로세스의 중단
    - 시스템의 유휴시간 문제를 프로세스 중단(일시정지) 상태를 이용 해결
    - 운영체제는 새로운 프로세스를 생성하여 실행하거나 실핼 중인 프로세스를 중단했다가 다시 실행하여 사용 가능.
    - 실행에서 대기가 아닌 중단 상태 추가하면 특정 이벤트의 발생을 기다리면서 대기 상태가 되어 해당 이벤트가 발생 할 때 즉시 실행 상태로 바꿀 수 있는 이점
    - 다중 프로그래밍에서의 중단
        - 프로세스 입출력 요구 외에 다른 원인으로 프로세스가 실행을 중단한 상태
    - 단일 처리 시스템 : 해당 프로세스 스스로 중단
    - 다중 처리 시스템 : 다른 프로세서가 실행중인 프로세스 중단
    - 중단된 프로세스는 다른 프로세서가 재시작 하기 전에는 실행 불가
    - 장시간 중단 시 해당 프로세스에 할당된 자원 반환, 자원의 성질에 따라 반환 자원 결정
        - 메인 메모리 : 프로세서 중단 즉시 반환
        - 보조 메모리 : 중단 시간 예측할 수 없거나 너무 길 때 반환
    - 중단한 프로세스는 중단한 지점부터 다시 시작

## 6. 프로세스의 우선순위
- 프로세스 스케줄러
    - 프로세스 제어 블록의 우선순위 이용하여 준비 리스트의 프로세스 처리
    - 준비 리스트의 프로세스는 프로세서 중심 프로세스와 입출력 중심 프로세스로 구분
    - 입출력 중심 프로세스는 속도가 느리면서 빠른 응답 요구하는 단말기 입출력 프로세스에 높은 우선순위 부여
    - 우선순위가 낮은 프로세스에는 시간을 많이, 우선순위가 높은 프로세스에는 적게 할당
    - 입출력 중심 프로세스는 프로세서를 짧게 자주 시용하도록 학소, 프로세서 중심 프로세스 프로세서를 길게 사용하되 횟수를 줄여 균형 유지

    
