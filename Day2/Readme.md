# 2주차.

- 다중 프로그래밍의 특징
    - 높고 효율적인 프로세서 사용율
    - 많은 사용자의 프로그램이 거의 동시에 프로세서를 할당 받는 느낌
    - 다중 프로그래밍 운영체제는 아주 복잡하다
    - 여러 작업을 준비상태로 두려면 이를 메모리에 보관, 일정 형태의 메모리를 관리 해야 함
    - 여러 작업이 수행 할 준비를 갖추고 있으면 이 중 하나를 선택하는 결정 방법 필요
    - 인터럽트 이용 수행하는 프로세서 스케줄링의 다중 프로그래밍으로 현재 운영체제의 중심 주제.

    * 스케줄링, 교착상태, 병행제어, 보호문제 등이 신중히 고려되어야 한다 !!

    - 스케줄링의 유형, 장기, 중기, 단기 스케줄링
    - 비선점형과 선점형
        - 비선점형 스케줄링 : 어떤 프로세스가 CPU를 할당 받으면 그 프로세스가 종료되거나 입출력 요구가 발생하여 자발적으로 중지될 때 까지 계속 실행되도록 보장한다
        - 선점형

- 시분할 시스템 TSS
    - 다중 프로그래밍을 논리적으로 확장한 개념, 프로세서가 다중 작업을 교대로 실행
    - 다수의 사용자가 동시에 컴퓨터의 자원을 공유 할 수 있는 기술
    - 프로그램에 일정한 프로세서 사용 시간 또는 규정 시간량 할당
    - 여러 사용자에게 짧은 간격으로 프로세서 번갈아 할당.

## 다중 프로그래밍 시스템과 시분할 시스템 특징
    - 메모리에 여러 프로그램을 적재하므로 메모리 관리 필요
    - 어떤 프로그램을 먼저 실행할지 결정하는 스케줄링 개념 필요
    - 다중 프로그래밍 시스템의 목표 : 프로세서 사용 최대화
    - 시분할 시스템의 목표 : 응답시간 최소화

## 다중 처리 시스템
- 다중 처리 시스템 (multiprocessing)
    - 단일 컴퓨터 시스템 내에서 둘 이상의 프로세서 사용, 동시에 둘 이상의 프로세스 지원
    - 여러 프로세서와 시스템 버스, 클록, 메모리와 주변장치등 공유
    - 빠르고 , 프로세서 하나가 고장나도 다른 프로세서 사용하여 작업 계속, 신뢰성 높음
    - 프로세서간의 연결, 상호작용, 역할 분담등을 고려해야함
    - 다중 처리 시스템을 구성하는 방법에는 비대칭(주종)적 구성과 대칭적 구성이 있음

- 실시간 처리 시스템 (real time processing systewm)
    - 데이터 처리 시스템으로 정의
    - 입력에 응답하는 데 필요한 시간 간격이 너무 짧아 환경 제어
    - 온라인 시스템은 실시간으로 할 필요가 없지만, 실시간 처리 시스템은 항상 온라인 상태
    - 입력 및 업데이트 된 정보 요구 처리 후 디스플레이에 응답하는 시스템에 소요 시간을 반응(응답) 시간으로 함
    - 반응 시간은 프로세서에 이미 고정
    - 더 높은 적시 응답을 요구하는 장소에서 사용하거나 데이터 흐름, 또는 프로세서 연산에 엄격한 시간 요구가 있을 때 사용 가능하다 (제어기, 임베디드 시스템, 원자로 시스템, 항공우주 시스템 등등)
    - 고정 시간 제약을 잘 정의하지 않으면 시스템 실패
    
- 실시간 처리 시스템의 두가지 유형
    - 경성 실시간 처리 시스템 (Hard RT)
        - 시간 제약을 지키지 못하면 실패, 정확성과 예측성, 정밀한 시간 제어
    - 연성 실시간 처리 시스템 (Soft RT)
        - 작업 실행에서 시간 제약 조건은 있으나, 이를 지키지 못해도 치명적인 영향을 않는 시스템
        - 실시간 동영상 스트리밍 시스템 (초당 일정 프레임 이상 영상을 재생 해야 된다는 제약은 있으나, 치명적이지는 않음)

## 분산 처리 시스템

- 분산처리 시스템
    - 시스템 마다 독립적인 운영체제와 메모리로 운영, 필요 시 통신하는 시스템
    - 사용자에게 중앙집중식 시스템처럼 보이는데, 다수의 독립된 프로세서에서 실행
    - 데이터를 여러 위치에서 처리, 저장, 여러 사용자가 공유

# 운영체제의 서비스

## 운영체제의 서비스 제공
- 부팅서비스: 컴퓨터 하드웨어 관리, 프로그램 실행 할 수 있도록 부팅
- 사용자 서비스 : 프로그래머가 프로그래밍 작업을 쉽ㄱ ㅔ할 수 있도록
- 시스템 서비스 : 시스템의 효율적인 동작 보장
- 시스템 호출 : 프로그램이 운영체제의 기능을 서비스 받을 수 있는 프로그램과 운영체제 간의 인터페이스 제공 (API, ABI 라고 부르는 것들,,?) -> System call

## 1. 부팅 시스템
- 부팅, 부트스트래핑
    - 운영체제를 메인 메모리에 적제하는 과정
    - 부트 로더는 부트스트랩 로더를 줄인 말로, 하드디스크와 같은 보조 기억 장치에 저장된 운영체제를 메인 메모리에 적재하는 ROM에 고정시킨 소규모 프로그램

* 추가적 공부~!

![1](images/1.png)

- 맥은 /System/Library/CoreServices/ 밑에 boot.efi 형식으로 boot에 필요한 파일들 저장
- 리눅스는 요즘 보통 /boot/efi 라는 지점에 마운트 된 파일을 읽고 부팅한다

- 부팅 되면 ROM에 저장된 부트 로더 실행
- 부팅하면 부트로더가 하드디스크에서 부팅에 필요한 파일들을(운영체제, 커널) 램에 적재한다.
- 이 때 부터 운영체제가 초기화 되고, 응용 프로그램 시작 -> 프로세서가 동작하여 사용자가 사용 가능!

## 사용자 서비스
- 사용자 인터페이스 제공
    - 사용자 인터페이스 : 사용자와 컴퓨터 간의 상호작용 발생 공간 (CLI, GUI)
- CLI : 명령라인 인터페이스
- 키보드로 사용자 명령어 입력 받아서 여러 동작을 수행

- GUI는 우리가 아는 맥, 리눅스(데스크탑), 윈도우 같은 운영체제에서 사용자들이 보는 화면이라고 볼 수 있다.

- 프로그램 실행
    - 프로그램 실행하려면 먼저 메모리에 적재 (HDD,SSD -> RAM) 프로세서 할당
    - 운영체제는 프로그램을 실행하려고 메모리 할당이나 해제, 스케줄링 등 중요 작업 처리

- 입출력 수행
    - 수행중인 프로그램은 입력이 필요, 사용자가 제공하는 입력 처리 후에는 출력을 생성,
    - 운영체제는 입출력 동작 직접 수행 할 수 없는 사용자 프로그램의 입출력 동작 방법 제공 
- 파일 시스템 조작
    - 사용자는 디스크에서 파일 열고, 저장 등 다양한 파일 조작
    - fopen, fwrite, fread ...

- 통신(네트워크)
    - 프로세서가 다른 프로세스와 정보를 교환하는 방법
        - 동일한 컴퓨터에서 수행하는 프로세스 간의 정보 교횐
        - 두 번째는 네트워크로 연결 된 컴퓨터 시스템에서 수행하는 프로세스간의 정보 교환
    - 운영체제는 다중 작업 환경에서 공유 메모리를 이용하거나 메시지 전달(IPC ) 다양한 유형의 프로세스와 통신 지원

- 오류 탐지
    - 운영체제는 가능한 모든 하드웨어와 소프트웨어 수준에서 오류 탐지
    - 입출력 장치에 관련된 오버플러우 등 오류 탐지

- 시스템 서비스
    - 여러 사용자에게 컴퓨터 자원 공유하여 시스템 자체의 효율성 높인다

- 자원 할당
    - 운영체제는 다수의 사용자나 작업 동시 실행 시 운영체제가 자원을 각각 할당하도록 관리
    - 프로세서 사이클, 메인 메모리, 파일 저장 장치 등은 특수한 할당 코드를 갖지만, 입출력 장치등은 더 많은 요청과 해제 코드를 가질 수 있다.

- 계정
    - 운영체제는 각 사용자가 어떤 컴퓨터 자원을 얼마나 사용하는지 로깅..

- 보호와 보안
    - 운영 체제는 다중 사용자 컴퓨터 시스템에 저장된 정보 소유자의 사용을 제한(ex: chown, chmod, cgroup, sudo su 등등)


## 시스템 호출 (System call)

- 실행 중인 프로그램과 운영체제 간의 인터페이스 Application Programming Interface , API 라고도 함
- 사용자 프로그램은 시스템 호출을 하여 운영체제의 기능 제공 받음
- 핵심 커널 서비스와 통신, 새로운 프로세스의 생성과 실행, 하드웨어 관련 서비스 등이 있음
- 시스템과 상호작용 하는 동작은 대개 사용자 수준 프로세스 에서는 사용 할 수 없으나, 시스템 호출을 하여 운영체제에 서비스를 요청 할 수 있음
- 시스템 호출 방법
    - 프로그램에서 명령이나 서브루틴의 호출 형태로 호출
    - 시스템에서 명령 해석기를 사용하여 대화 형태로 호출
- 운영체제가 제공하는 일반적인 시스템 호출
    - 프로세스 제어, 파일 조작, 장치 관리, 정보 유지 등등

|호출 서비스|설명|
|:---------|:---------|
|프로세스 제어| * 종료와 취소 * 프로세스 속성 획득과 지정 <br/> * 적재와 실행 * 대기와 대기 이벤트, 신호 이벤트 <br/> * 프로세스 생성과 종료 * 메모리 할당과 헤제|
|파일 조작| * 파일 생성과 삭제 * 파일 읽기와 쓰기, 파일 재배치 <br/> * 파일 열기와 닫기 * 파일 속성 획득과 지정|
|장치 조작| * 장치 요구와 해제 * 장치 속성 획득과 설정 <br/> * 장치 읽기와 쓰기, 재배치 * 논리적 부착이나 장치 제거|
|정보 관리| * 시간과 날짜의 설정과 획득 * 데이터의 설정과 획득 <br/> 프로세스 파일, 장치 속성의 설정과 획득|
|통신| * 통신 연결의 생성과 제거 * 정보 상태 전달 <br/> * 메시지의 송수신 * 원격 장치의 부착 및 제거|

시스템 콜 예제

```C
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>

// filename 으로 파일을 만드는 코드. creat 시스템 콜 이용.
//create 이 아닌것에 주의하기.

int main() {
    int fd;
    char *filename = "test_file";
    //fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644); //아래 코드와 동일하다고 한다.
    fd = creat(filename, 0644);
    if (fd == -1) {
        printf("this is error");
    }
    else{
        printf("create file!\n");
        printf("this is fd number %d", fd); //fd = 3
    }

    return 0;
}
```

* 웃긴 이야기. create가 아닌 creat 인것 -> 보면 알겠지만 오타인데, 이제는 고칠 수 없게 됨. 해당 명령어 개발한 개발자 아직도 후회중이라고 함

 
- 시스템 콜 흐름

![2](images/2.png)

## 운영체제의 구조

- 운영체제가 점점 다양한 하드웨어와 소프트웨어 지원하면서 구조 또한 복잡해짐

![3](images/3.png)
- 실제 리눅스 커널 코드 깃헙 arch(아키텍쳐 별 코드)목록, 다양한 아키텍쳐 지원한다

## 1. 단일 구조 운영체제
- 단일 구조(모놀로식 커널 구조) 운영 체제
    - 초기에 생겨난 가장 보편적 형태
    - 운영체제의 모든 기능을 커널과 동일한 메모리 공간에 적재 후 시스템 콜 사용
    - 작고 간단하면서 시스템 기능이 제한된 구조

- 특징
    - 대부분의 기능을 커널에 그룹화해서 구현, 직접 통ㄹ신하여 시스템 자원을 효율적 관리
    - 커널 크기가 상대적으로 커지면서 버그의 원인이나 기타 오류 구분이 어려움
    - 새 기능을 추가하는 수정과 유지 보수 매우 어려움
    - 동일한 메모리에서 실행하므로 한 부분에서 발생한 문제로 시스템 전체에 심각한 영향을 끼침

## 2. 계층 구조 운영체제
- 운영체제가 점점 커지고 복잡해지면서 순수 단일 구조만으로는 다루기가 어려워 졌다
- 계층 구조에서는 비슷한 기능을 수행하는 요소를 그룹화 하여 계층적으로 구성
- 사용자 프로세스의 요청을 수행 할 때 여러 계층을 거쳐야 하므로, 한 계층에서 다음 계층으로 데이터를 전달할 때 마다 추가적인 시스템 호출 발생
- 호출 한 번으로 서비스를 받는 단일 구조보다는 성능 낮음
- 단일 구조 운영체제보다 모듈화가 잘 되어 있음
- 시스템 검증과 오류 수정 용이
- 첫번째 계층은 기본 하드웨어 사용하여 기능을 만들어 나머지 시스템에 의문을 가지지 않고 오류를 수정 가능
- 첫 번째 계층의 오류를 수정하면 기능이 정확하다고 가정하여 두번째 계층 만듬
- 시스템을 계층으로 나누면 시스템 설계나 구현 단순해짐

* 계층 정의가 어려운 단점

* 각 계층은 자신의 하위 계층만 사용 할 수 있으므로 신중하게 설계 함

* 대형 시스템의 프로세서 스케줄러에서 메모리에 적재 할 수 있는 것보다 활동 중인 프로세스를 더 많이 처리하려면 교체(스와핑) 기능 필요

* 모든 계층이 시스템에 제한 없이 접근 할 수 있어 오류나 악성코드에 민감하게 반응 할 수 있음.


## 3. 마이크로 커널 구조 운영체제

- 커널 기능 많이 제외

- 커널에는 최소 기능만 포함시켜 크기를 대폭 줄이고 기타 기능은 사용자 공간으로 옮겨 사용자 영역에서 수행하는 서버 구현

- 하드웨어 초기화, 메모리 관리, 프로세스(스레드) 관리, 프로세스 간 통신, 프로세스 간 협력 동기화 기능 등 기본 기능만 실행

- 네트워크 시스템, 파일 시스템 상호작용과 장치 관리 등 대부분의 운영체제 구성 요소는 커널 외부, 즉 사용자 영역의 서버로 옮겨 구현

